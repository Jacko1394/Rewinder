<span>// Bridge.cs&para;<br>// MAGIQ Documents&para;<br>// Created by Jack Della on 1/03/2019&para;<br>// Copyright Â© 2019 MAGIQ Software Ltd. All rights reserved.&para;<br>&para;<br>using System;&para;<br>using System.IO;&para;<br>using System.Linq;&para;<br>using System.Reflection;&para;<br>using System.Threading.Tasks;&para;<br>using System.Collections.Generic;&para;<br>&para;<br>using Xamarin.Forms;&para;<br>using Xamarin.Essentials;&para;<br>using Microsoft.Extensions.Logging;&para;<br>using Plugin.FilePicker;&para;<br>&para;<br>using Magiq.Mobile.Main.Views;&para;<br>using Magiq.Mobile.Main.Models;&para;<br>using Magiq.Mobile.Common;&para;<br>using Magiq.Mobile.Database;&para;<br>using Magiq.Mobile.Main.Interfaces;&para;<br>using Magiq.Mobile.Extensions;&para;<br>using Magiq.Mobile.Main.ViewModels;&para;<br>using Magiq.Mobile.InfoRouter;&para;<br>using Magiq.Mobile.Models;&para;<br>using Magiq.Mobile.Main.Models.Resource;&para;<br>using Magiq.Mobile.FileInfoWrapper;&para;<br>using Magiq.Mobile.Interfaces;&para;<br>&para;<br>namespace Magiq.Mobile.Main.Services {&para;<br>&para;<br>	public class Bridge {&para;<br>&para;<br>		public const string Wait = "WAIT"; // indefinite wait&para;<br>&para;<br>		internal WebViewModel? WebVm { get; set; }&para;<br>		internal string MenuItem { get; set; } = string.Empty;&para;<br>&para;<br>		public void Init(Action action) =&gt; SetBusy = action; // inject this&para;<br>&para;<br>		private Action? SetBusy; // kill pls&para;<br>&para;<br>		private readonly ILogger _logger;&para;<br>		private readonly IAppFacade _app;&para;<br>		private readonly ICredentialService _credentialService;&para;<br>		private readonly IPageFactory _pageFactory;&para;<br>		private readonly PhotoPicker _photo;&para;<br>		private readonly Settings _settings;&para;<br>&para;<br>		private static readonly Dictionary&lt;string, MethodInfo&gt; BridgeMethods;&para;<br>&para;<br>		public static readonly string[] MethodsToExclude = {&para;<br>			"finalize",&para;<br>			"get_WebVm",&para;<br>			"set_WebVm",&para;<br>			"memberwiseClone",&para;<br>			"set_MenuItem",&para;<br>			"&lt;ShowTaskPage&gt;b__30_0",&para;<br>			"equals",&para;<br>			"getHashCode",&para;<br>			"getType",&para;<br>			"init",&para;<br>			"theNativeFunction",&para;<br>			"toString"&para;<br>		};&para;<br>&para;<br>		static Bridge() {&para;<br>			BridgeMethods = typeof(Bridge)&para;<br>				.GetMethods(BindingFlags.Public | BindingFlags.Instance)&para;<br>				.Where(x =&gt; !MethodsToExclude.Contains(x.Name, StringComparer.OrdinalIgnoreCase))&para;<br>				.ToDictionary(x =&gt; x.Name);&para;<br>		}&para;<br>&para;<br>		public Bridge(&para;<br>			ILogger&lt;WebViewModel&gt; logger,&para;<br>			PhotoPicker photo,&para;<br>			Settings settings,&para;<br>			IPageFactory pageFactory,&para;<br>			ICredentialService credentialService,&para;<br>			IAppFacade appFacade&para;<br>		) {&para;<br>			_logger = logger;&para;<br>			_photo = photo;&para;<br>			_settings = settings;&para;<br>			_pageFactory = pageFactory;&para;<br>			_credentialService = credentialService;&para;<br>			_app = appFacade;&para;<br>		}&para;<br>&para;<br>		public async Task&lt;string&gt; TheNativeFunction(string json) {&para;<br>&para;<br>			try {&para;<br>&para;<br>				var request = SenchaRequest.ReadCommand(json);&para;<br>&para;<br>				if (request is null) {&para;<br>					return Result.Fail(Error.NullParams).ToString();&para;<br>				}&para;<br>&para;<br>				var methodExists = BridgeMethods.TryGetValue(request.Command, out var method);&para;<br>&para;<br>				if (!methodExists) {&para;<br>					_logger.LogWarning("BRIDGE METHOD DOESN'T EXIST");&para;<br>					return Result.Fail(Error.CantDoIt).ToString();&para;<br>				}&para;<br>&para;<br>				var paramsArray = method.GetParameters();&para;<br>&para;<br>				if (paramsArray.Length != request.Params.Length) {&para;<br>&para;<br>					if (request.Params.Length &lt; paramsArray.Length) {&para;<br>&para;<br>						var requestParams = request.Params.ToList();&para;<br>&para;<br>						for (var i = 0; i &lt; paramsArray.Length - request.Params.Length; ++i) {&para;<br>							requestParams.Add(string.Empty); // add empty strings&para;<br>						}&para;<br>&para;<br>						request.Params = requestParams.ToArray();&para;<br>&para;<br>					} else {&para;<br>						var error = "Bridge ERROR: Too many parameters. The Native.js file might need to be regenerated.";&para;<br>						_logger.LogWarning(error);&para;<br>						_logger.LogWarning(request.ToJson());&para;<br>						return Result.Fail(error).ToString();&para;<br>					}&para;<br>&para;<br>				}&para;<br>&para;<br>				var args = paramsArray.Length &lt; 1 ? new string[0] : request.Params;&para;<br>&para;<br>				_logger.LogInformation($"Bridge: {method.Name} : {args.ToJson()}");&para;<br>&para;<br>				var methodTask = method.Invoke(this, args);&para;<br>&para;<br>				if (methodTask is Result plainResult) {&para;<br>					return plainResult.ToString();&para;<br>				}&para;<br>&para;<br>				if (methodTask is Task&lt;Result&gt; asyncPlainResult) {&para;<br>					var returnJson = await asyncPlainResult;&para;<br>					return returnJson.ToString();&para;<br>				}&para;<br>&para;<br>				// &lt;object&gt; enables me to pass any structure straight in, json.net will serialize it and pass thru bridge&para;<br>				if (methodTask is Result&lt;object&gt; result) {&para;<br>					return result.ToString();&para;<br>				}&para;<br>&para;<br>				if (methodTask is Task&lt;Result&lt;object&gt;&gt; asyncResult) {&para;<br>					var returnJson = await asyncResult;&para;<br>					return returnJson.ToString();&para;<br>				}&para;<br>&para;<br>				if (methodTask is string stringResult) {&para;<br>&para;<br>					if (stringResult == Wait) {&para;<br>						return Wait;&para;<br>					}&para;<br>&para;<br>					return Result&lt;string&gt;.Succeed(stringResult).ToString();&para;<br>				}&para;<br>&para;<br>				if (methodTask is Task&lt;string&gt; asyncStringResult) {&para;<br>&para;<br>					var returnJson = await asyncStringResult;&para;<br>&para;<br>					if (returnJson == Wait) {&para;<br>						return Wait;&para;<br>					}&para;<br>&para;<br>					return Result&lt;string&gt;.Succeed(returnJson).ToString();&para;<br>				}&para;<br>&para;<br>				// SHOULD NEVER REACH HERE...&para;<br>				// All Bridge methods should only return Result or Result&lt;object&gt;&para;<br>				return Result&lt;object&gt;.Fail("Error occurred on Native side, C# method was not in correct format.", methodTask).ToString();&para;<br>			} catch (TargetInvocationException tex) {&para;<br>				if (tex?.InnerException is { } inner) {&para;<br>					if (inner is SenchaException sex) {&para;<br>						sex.Error(); // report&para;<br>					} else {&para;<br>						_logger.LogError("Bridge Reflection INNER ERROR", inner);&para;<br>					}&para;<br>				} else {&para;<br>					_logger.LogError("Bridge Reflection ERROR", tex);&para;<br>				}&para;<br>				return Result.Succeed.ToString();&para;<br>			} catch (InvalidOperationException mex) {&para;<br>				return Result.Fail(mex.Message).ToString();&para;<br>			} catch (Exception ex) {&para;<br>				return Result.Fail(ex.Error()).ToString();&para;<br>			}&para;<br>&para;<br>		}&para;<br>&para;<br>		#region BridgeFuncs&para;<br>&para;<br>		public Result&lt;object&gt; RunSql(string sqlStatement) {&para;<br>			return Result&lt;object&gt;.Succeed(App.GetService&lt;Sql&gt;().Query(sqlStatement));&para;<br>		}&para;<br>&para;<br>		public async Task&lt;Result&lt;object&gt;&gt; OpenFilePicker() {&para;<br>&para;<br>			var file = await CrossFilePicker.Current.PickFile();&para;<br>&para;<br>			if (file is null) { // cancelled&para;<br>				return Result&lt;object&gt;.Fail("Cancelled by User");&para;<br>			}&para;<br>&para;<br>			return Result&lt;object&gt;.Succeed(new LocalFile(file.FilePath));&para;<br>		}&para;<br>&para;<br>		// Menu:&para;<br>		public Result HideMenu() {&para;<br>			Device.BeginInvokeOnMainThread(() =&gt; {&para;<br>				if (App.Main is MasterDetailPage main) {&para;<br>					main.IsPresented = false;&para;<br>				}&para;<br>			});&para;<br>			return Result.Succeed;&para;<br>		}&para;<br>&para;<br>		public Result</span><ins style="background:#e6ffe6;">&lt;object&gt; GetEnvironment() {&para;<br>			if (_settings.SelectedConfiguration is null) {&para;<br>				return Result&lt;object&gt;.Fail("No MAGIQ environment has been configured yet!");&para;<br>			}&para;<br>			return Result&lt;object&gt;.Succeed(_settings.SelectedConfiguration);&para;<br>		}&para;<br>&para;<br>		public Result</ins><span> ShowMenu() {&para;<br>			Device.BeginInvokeOnMainThread(() =&gt; {&para;<br>				if (App.Main is MasterDetailPage main) {&para;<br>					main.IsPresented = true;&para;<br>				}&para;<br>			});&para;<br>			return Result.Succeed;&para;<br>		}&para;<br>&para;<br>		// Xamarin:&para;<br>		public async Task&lt;Result&gt; DisplayMessage(string title, string message, string button) {&para;<br>			await App.Msg(title, message, button);&para;<br>			return Result.Succeed;&para;<br>		}&para;<br>&para;<br>		[Summary("Destruction = </span><ins style="background:#e6ffe6;">G</ins><span>RE</span><del style="background:#ffe6e6;">D</del><ins style="background:#e6ffe6;">EN</ins><span>, for important/dangerous operations, leave null if n/a.  Up to 5 choices, leave empty for none.")]&para;<br>		public async Task&lt;string&gt; DisplayActionsheet(string title, string cancel, string destruction, string btn1, string btn2, string btn3, string btn4, string btn5) {&para;<br>			var args = new List&lt;string&gt; { btn1, btn2, btn3, btn4, btn5 }.Where(x =&gt; !string.IsNullOrWhiteSpace(x)).ToArray();&para;<br>			return await Application.Current.MainPage.DisplayActionSheet(title, cancel, destruction, args);&para;<br>		}&para;<br>&para;<br>		// Files:&para;<br>		public async Task&lt;Result&lt;object&gt;&gt; SaveFile(string key, string value) {&para;<br>			var save = new XFile(Under.Documents, MenuItem, key);&para;<br>			await save.Save(value);&para;<br>			return Result&lt;object&gt;.Succeed(save.Path);&para;<br>		}&para;<br>&para;<br>		public async Task&lt;string&gt; LoadFile(string key) {&para;<br>			var str = await new XFile(Under.Documents, MenuItem, key).Load&lt;string&gt;();&para;<br>			str ??= "null";&para;<br>			return str;&para;<br>		}&para;<br>&para;<br>		public Result&lt;object&gt; LoadFileList() {&para;<br>			var list = new XFolder(Under.Documents).Children;&para;<br>			return Result&lt;object&gt;.Succeed(list);&para;<br>		}&para;<br>&para;<br>		public Result DeleteFile(string key) {&para;<br>			new XFile(Under.Documents, MenuItem, key).Delete();&para;<br>			return Result.Succeed;&para;<br>		}&para;<br>&para;<br>		// Pages:&para;<br>		[DocumentsMethod]&para;<br>		public Result ShowOfflineDocs() {&para;<br>			Device.BeginInvokeOnMainThread(() =&gt; _app.GetNavigation.PushAsync(App.GetService&lt;OfflineDocsPage&gt;()));&para;<br>			return Result.Succeed;&para;<br>		}&para;<br>&para;<br>		[DocumentsMethod]&para;<br>		public Result ShowUploadPage(string directory) {&para;<br>			try {&para;<br>&para;<br>				if (Path.HasExtension(directory)) {&para;<br>					directory = Path.GetDirectoryName(directory); // if its a file, chop it off&para;<br>				}&para;<br>&para;<br>				Device.BeginInvokeOnMainThread(() =&gt; _app.GetNavigation.PushAsync(new UploadPage(directory)));&para;<br>			} catch (Exception ex) {&para;<br>				ex.Error();&para;<br>			}&para;<br>			return Result.Succeed;&para;<br>		}&para;<br>&para;<br>		[DocumentsMethod]&para;<br>		public Result ShowTaskPage() {&para;<br>			Device.BeginInvokeOnMainThread(() =&gt; _app.GetNavigation.PushAsync(_pageFactory.GetTaskPage(WebVm)));&para;<br>			return Result.Succeed;&para;<br>		}&para;<br>&para;<br>		// Media:&para;<br>		[Summary("Will take a device screenshot, and return the photo data as a base64string.")]&para;<br>		public async Task&lt;Result&lt;object&gt;&gt; GetScreenshot() {&para;<br>			var pic = await _photo.GetScreenshot();&para;<br>			return Result&lt;object&gt;.Succeed(pic.ToBase64String());&para;<br>		}&para;<br>&para;<br>		[Summary("Returns the photo data as a base64string.")]&para;<br>		public async Task&lt;Result&lt;object&gt;&gt; GetPhoto(string choice) {&para;<br>&para;<br>			var option = Choice.None;&para;<br>&para;<br>			if (choice == "take") {&para;<br>				option = Choice.Take;&para;<br>			} else if (choice == "pick") {&para;<br>				option = Choice.Pick;&para;<br>			}&para;<br>&para;<br>			var file = await _photo.GetPhoto(option);&para;<br>			if (file is { }) {&para;<br>				var pic = await file.Load&lt;Stream&gt;();&para;<br>&para;<br>				if (pic is { }) {&para;<br>					var data = pic.ToBase64String();&para;<br>&para;<br>					if (data.Length &gt; 50_000_000) {&para;<br>						return Result&lt;object&gt;.Fail("The selected photo was too large to pass thru the bridge.");&para;<br>					}&para;<br>&para;<br>					return Result&lt;object&gt;.Succeed(data);&para;<br>				}&para;<br>			}&para;<br>			return Result&lt;object&gt;.Fail("Operation was cancelled by user.");&para;<br>		}&para;<br>&para;<br>		[Summary("Returns the video data as a base64string.")]&para;<br>		public async Task&lt;Result&lt;object&gt;&gt; GetVideo(string choice) {&para;<br>&para;<br>			var option = Choice.None;&para;<br>&para;<br>			if (choice == "take") {&para;<br>				option = Choice.Take;&para;<br>			} else if (choice == "pick") {&para;<br>				option = Choice.Pick;&para;<br>			}&para;<br>&para;<br>			var file = await _photo.GetVideo(option);&para;<br>			if (file is { }) {&para;<br>&para;<br>				var pic = await file.Load&lt;Stream&gt;();&para;<br>&para;<br>				if (pic is { }) {&para;<br>					var data = pic.ToBase64String();&para;<br>&para;<br>					if (data.Length &gt; 50_000_000) {&para;<br>						return Result&lt;object&gt;.Fail("The selected video was too large to pass thru the bridge.");&para;<br>					}&para;<br>&para;<br>					return Result&lt;object&gt;.Succeed(data);&para;<br>				}&para;<br>			}&para;<br>			return Result&lt;object&gt;.Fail("Operation was cancelled by user.");&para;<br>		}&para;<br>&para;<br>		[DocumentsMethod]&para;<br>		public async Task&lt;Result&lt;object&gt;&gt; ShareDocument(string filename, string id) {&para;<br>			SetBusy?.Invoke();&para;<br>			return await Helper.DownloadAndSave(filename, $"~{id}", Then.Share);&para;<br>		}&para;<br>&para;<br>		// PUBLIC for TaskVm&para;<br>		[DocumentsMethod]&para;<br>		public async Task&lt;Result&lt;object&gt;&gt; ViewDocument(string filename, string id) {&para;<br>			SetBusy?.Invoke();&para;<br>			return await Helper.DownloadAndSave(filename, $"~{id}", Then.View);&para;<br>		}&para;<br>&para;<br>		[DocumentsMethod]&para;<br>		public async Task&lt;Result&lt;object&gt;&gt; SaveOffline(string filename, string id) {&para;<br>			SetBusy?.Invoke();&para;<br>			return await Helper.DownloadAndSave(filename, $"~{id}", Then.SaveOffline);&para;<br>		}&para;<br>&para;<br>		public async Task&lt;Result&gt; ViewUrl(string url, string title) { // title = string.IsNullOrWhiteSpace(title) ? MenuItem : title;&para;<br>			title = string.IsNullOrWhiteSpace(title) ? MenuItem : title;&para;<br>			return await Viewer.Open(WebResource.Website(title, url));&para;<br>		}&para;<br>&para;<br>		public async Task&lt;Result&gt; ViewOfflineDocument(string filename) {&para;<br>			var doc = new LocalFile(Under.Documents, filename);&para;<br>			await Viewer.Open(doc);&para;<br>			return Result.Succeed;&para;<br>		}&para;<br>&para;<br>		[Summary("Valid choices: 'take' OR 'pick' only.")]&para;<br>		[Summary("Must specify a filename with '.jpg' extension.")]&para;<br>		public async Task&lt;Result&gt; CreateOfflinePhoto(string filename, string choice) {&para;<br>&para;<br>			var option = Choice.None;&para;<br>&para;<br>			if (choice == "take") {&para;<br>				option = Choice.Take;&para;<br>			} else if (choice == "pick") {&para;<br>				option = Choice.Pick;&para;<br>			}&para;<br>&para;<br>			var file = await _photo.GetPhoto(option);&para;<br>&para;<br>			if (file is { }) {&para;<br>				var save = new XFile(Under.Documents, filename);&para;<br>				file.Move(save);&para;<br>				return Result.Succeed;&para;<br>			}&para;<br>&para;<br>			return Result.Fail("Operation was cancelled by user.");&para;<br>		}&para;<br>&para;<br>		[Summary("</span><del style="background:#ffe6e6;">Valid choices: 'take' OR 'pick' only.")]&para;<br>		[Summary("</del><span>Must specify a filename with '.mp4' extension</span><ins style="background:#e6ffe6;">.")]&para;<br>		[Summary("Valid choices: 'take' OR 'pick' only</ins><span>.")]&para;<br>		public async Task&lt;Result&gt; CreateOfflineVideo(string filename, string choice) {&para;<br>&para;<br>			var option = Choice.None;&para;<br>&para;<br>			if (choice == "take") {&para;<br>				option = Choice.Take;&para;<br>			} else if (choice == "pick") {&para;<br>				option = Choice.Pick;&para;<br>			}&para;<br>&para;<br>			var file = await _photo.GetVideo(option);&para;<br>&para;<br>			if (file is { }) {&para;<br>				var save = new XFile(Under.Documents, filename);&para;<br>				file.Move(save);&para;<br>				return Result.Succeed;&para;<br>			}&para;<br>&para;<br>			return Result.Fail("Operation was cancelled by user.");&para;<br>		}&para;<br>&para;<br>		// Messaging:&para;<br>		public async Task&lt;Result&gt; CreateEmail(string to, string subject, string messageBody) {&para;<br>			var serv = App.GetService&lt;IEmailService&gt;();&para;<br>&para;<br>			await await App.MainThreadAsync(() =&gt; serv.CreateEmail(to, subject, messageBody));&para;<br>&para;<br>			return Result.Succeed;&para;<br>		}&para;<br>&para;<br>		public async Task&lt;Result&gt; CreateEmailWithAttatchment(string to, string subject, string messageBody, string filename) {&para;<br>			var serv = App.GetService&lt;IEmailService&gt;();&para;<br>			await await App.MainThreadAsync(() =&gt; serv.CreateEmail(to, subject, messageBody, new XFile(Under.Documents, MenuItem, filename)));&para;<br>			return Result.Succeed;&para;<br>		}&para;<br>&para;<br>		public async Task&lt;Result&gt; CreateSms(string to, string messageBody) {&para;<br>			var serv = App.GetService&lt;IEmailService&gt;();&para;<br>			await await App.MainThreadAsync(() =&gt; serv.CreateSms(to, messageBody));&para;<br>			return Result.Succeed;&para;<br>		}&para;<br>&para;<br>		// InfoRouter:&para;<br>		[DocumentsMethod]&para;<br>		public async Task&lt;Result&gt; AddFav(string id) {&para;<br>			SetBusy?.Invoke();&para;<br>			await App.GetService&lt;IInfoRouterClient&gt;().AddToFavorites($"~{id}");&para;<br>			return Result.Succeed;&para;<br>		}&para;<br>&para;<br>		[DocumentsMethod]&para;<br>		public async Task&lt;Result&gt; RemoveFav(string id) {&para;<br>			SetBusy?.Invoke();&para;<br>			await App.GetService&lt;IInfoRouterClient&gt;().RemoveFromFavorites($"~{id}");&para;<br>			return Result.Succeed;&para;<br>		}&para;<br>&para;<br>		[DocumentsMethod]&para;<br>		public Result&lt;object&gt; GetInfoRouterUser() {&para;<br>			var ir = App.GetService&lt;IInfoRouterClient&gt;();&para;<br>			if (!ir.IsAuthenticated) {&para;<br>				return Result&lt;object&gt;.Fail("Could not authenticate with the MAGIQ Documents server.", ir.User);&para;<br>			}&para;<br>			return Result&lt;object&gt;.Succeed(ir.User);&para;<br>		}&para;<br>&para;<br>		[DocumentsMethod]&para;<br>		public async Task&lt;Result&lt;object&gt;&gt; GetInfoRouterTasks() {&para;<br>			if (!App.GetService&lt;IInfoRouterClient&gt;().IsAuthenticated) {&para;<br>				return Result&lt;object&gt;.Fail("Could not authenticate with the MAGIQ Documents server.", App.GetService&lt;IInfoRouterClient&gt;().User);&para;<br>			}&para;<br>&para;<br>			var result = await App.GetService&lt;IInfoRouterClient&gt;().GetTasks("&lt;CRITERIA&gt;&lt;ITEM NAME=\"TASKCOMPLETIONSTATUS\" VALUE=\"0\" /&gt;&lt;/CRITERIA&gt;", "3", true);&para;<br>&para;<br>			if (!result.Success) {&para;<br>				return Result&lt;object&gt;.Fail(result.Error ?? "Couldn't get Tasks.");&para;<br>			}&para;<br>&para;<br>			return Result&lt;object&gt;.Succeed(result.Tasks);&para;<br>		}&para;<br>&para;<br>		// Device:&para;<br>		public async Task&lt;Result&lt;object&gt;&gt; GetLocation() {&para;<br>			try {&para;<br>				//todo TEST&para;<br>				var location = await await App.MainThreadAsync(Geolocation.GetLocationAsync);&para;<br>				return Result&lt;object&gt;.Succeed(location);&para;<br>			} catch (Exception ex) {&para;<br>				return Result&lt;object&gt;.Fail(ex.Error());&para;<br>			}&para;<br>		}&para;<br>&para;<br>		[Summary("https://docs.microsoft.com/en-us/dotnet/api/xamarin.essentials.navigationmode")]&para;<br>		public async Task&lt;Result&gt; PushMapLocation(string lat, string lon, string name, string navigationMode) {&para;<br>			try {&para;<br>&para;<br>				var mode = NavigationMode.None;&para;<br>&para;<br>				if (!string.IsNullOrWhiteSpace(navigationMode)) {&para;<br>					if (!Enum.TryParse(navigationMode, out mode)) {&para;<br>						return Result.Fail("Invalid NavigationMode was specified.");&para;<br>					}&para;<br>				}&para;<br>&para;<br>				var options = new MapLaunchOptions {&para;<br>					Name = name,&para;<br>					NavigationMode = mode&para;<br>				};&para;<br>				await Map.OpenAsync(Convert.ToDouble(lat), Convert.ToDouble(lon), options);&para;<br>				return Result.Succeed;&para;<br>			} catch {&para;<br>				return Result.Fail(Error.BadAddress);&para;<br>			}&para;<br>		}&para;<br>&para;<br>		[Summary("Pass NavMode as string =&gt; 'None', 'Driving' etc...")]&para;<br>		public async Task&lt;Result&gt; PushMapAddress(string address, string navigationMode) {&para;<br>			try {&para;<br>&para;<br>				var mode = NavigationMode.None;&para;<br>&para;<br>				if (!string.IsNullOrWhiteSpace(navigationMode)) {&para;<br>					if (!Enum.TryParse(navigationMode, out mode)) {&para;<br>						return Result.Fail("Invalid NavigationMode was specified.");&para;<br>					}&para;<br>				}&para;<br>&para;<br>				var location = await Geocoding.GetLocationsAsync(address);&para;<br>				var options = new MapLaunchOptions {&para;<br>					Name = address,&para;<br>					NavigationMode = mode&para;<br>				};&para;<br>				await Map.OpenAsync(location.FirstOrDefault(), options);&para;<br>				return Result.Succeed;&para;<br>			} catch {&para;<br>				return Result.Fail(Error.BadAddress);&para;<br>			}&para;<br>		}&para;<br>&para;<br>		public Result PlaceCall(string number) {&para;<br>			Device.BeginInvokeOnMainThread(() =&gt; {&para;<br>				try {&para;<br>					PhoneDialer.Open(number);&para;<br>				} catch (Exception ex) {&para;<br>					ex.Error();&para;<br>				}&para;<br>			});&para;<br>			return Result.Succeed;&para;<br>		}&para;<br>&para;<br>		public async Task&lt;Result&lt;object&gt;&gt; GetClipboard() {&para;<br>			if (Clipboard.HasText) {&para;<br>				var text = await Clipboard.GetTextAsync();&para;<br>				return Result&lt;object&gt;.Succeed(text);&para;<br>			}&para;<br>			return Result&lt;object&gt;.Fail("Nothing in the Clipboard");&para;<br>		}&para;<br>&para;<br>		public async Task&lt;Result&gt; SetClipboard(string text) {&para;<br>			try {&para;<br>				await Clipboard.SetTextAsync(text);&para;<br>				return Result.Succeed;&para;<br>			} catch (Exception ex) {&para;<br>				return Result.Fail(ex.Error());&para;<br>			}&para;<br>		}&para;<br>&para;<br>		// MAGIQ:&para;<br>		[DocumentsMethod]&para;<br>		[Summary("Properties: 'ticket', 'libPrefs'")]&para;<br>		public Result&lt;object&gt; GetDocumentsInit() {&para;<br>&para;<br>			var ir = App.GetService&lt;IInfoRouterClient&gt;();&para;<br>&para;<br>			if (!ir.IsAuthenticated) {&para;<br>				return Result&lt;object&gt;.Fail("Could not authenticate with the MAGIQ Documents server.", ir.User);&para;<br>			}&para;<br>&para;<br>			var final = new {&para;<br>				ir.User.Ticket,&para;<br>				libPrefs = GetSetting("libPrefs").Data&para;<br>			};&para;<br>&para;<br>			return Result&lt;object&gt;.Succeed(final);&para;<br>		}&para;<br>&para;<br>		public Result&lt;object&gt; GetUserEmail() {&para;<br>			return Result&lt;object&gt;.Succeed(_credentialService.User.Email);&para;<br>		}&para;<br>&para;<br>		public Result&lt;object&gt; GetEnvironment() {&para;<br>			if (_settings.SelectedConfiguration is null) {&para;<br>				return Result&lt;object&gt;.Fail("No MAGIQ environment has been configured yet!");&para;<br>			}&para;<br>			return Result&lt;object&gt;.Succeed(_settings.SelectedConfiguration);&para;<br>		}&para;<br>&para;<br>		// Notifications: //TODO: work on Notification service...&para;<br>		public Result&lt;object&gt; CreateNotification(string title, string message, string date) {&para;<br>			var data = App.GetService&lt;INotifier&gt;().CreateNotififation(title, message, date);&para;<br>			return Result&lt;object&gt;.Succeed(data);&para;<br>		}&para;<br>&para;<br>		public Result&lt;object&gt; CreateAlarm(string title, string date) {&para;<br>			var data = App.GetService&lt;INotifier&gt;().CreateAlarm(title, date);&para;<br>			return Result&lt;object&gt;.Succeed(data);&para;<br>		}&para;<br>&para;<br>		public Result&lt;object&gt; GetNotificationList() {&para;<br>			return Result&lt;object&gt;.Succeed(App.GetService&lt;INotifier&gt;().GetNotificationList());&para;<br>		}&para;<br>&para;<br>		[DocumentsMethod]&para;<br>		public string LookIn() {&para;<br>			Device.BeginInvokeOnMainThread(() =&gt; {&para;<br>				_app.GetNavigation.PushModalAsync(_pageFactory.GetPage&lt;LibraryPage&gt;().InNavPage(new NavConfig(Icons.fa_close, "Cancel")));&para;<br>			});&para;<br>			return Result.Succeed.ToString();&para;<br>		}&para;<br>&para;<br>		public Result SetSetting(string key, string value) {&para;<br>			Preferences.Set(MenuItem + key, value);&para;<br>			return Result.Succeed;&para;<br>		}&para;<br>&para;<br>		public Result&lt;object&gt; GetSetting(string key) {&para;<br>			var result = Preferences.Get(MenuItem + key, null);&para;<br>			return result == null ? Result&lt;object&gt;.Fail("key not present in pref store") : Result&lt;object&gt;.Succeed(result);&para;<br>		}&para;<br>&para;<br>&para;<br>		//Testing</span><ins style="background:#e6ffe6;"> YOLO</ins><span>:&para;<br>		[Summary("Adds a string to the native error log. Collects silently, and sends to AppCenter to diagnose.")]&para;<br>		public Result ReportError(string error, string error2, string error3) {&para;<br>			error = $"{MenuItem} Error:\n{error}";&para;<br>			error += error2 + error3;&para;<br>			throw new SenchaException(error);&para;<br>		}&para;<br>&para;<br>&para;<br>		// Helper:&para;<br>		private enum Then : byte { Share, SaveOffline, View }&para;<br>&para;<br>		// private class so not picked up in BridgeGeneration:&para;<br>		private static class Helper {&para;<br>&para;<br>			public static async Task&lt;Result&lt;object&gt;&gt; DownloadAndSave(string name, string id, Then doThis) {&para;<br>&para;<br>				string? text;&para;<br>				var result = await App.GetService&lt;IInfoRouterClient&gt;().DownloadDocument(id);&para;<br>&para;<br>				if (result.Success) {&para;<br>					text = result.Base64Binary ?? string.Empty;&para;<br>				} else {&para;<br>					text = result.Error ?? "The download contains no data. Your MAGIQ Documents session may need to be refreshed.";&para;<br>					await App.Msg("Download Error", text, "OK");&para;<br>					return Result&lt;object&gt;.Fail(text);&para;<br>				}&para;<br>&para;<br>				if (string.IsNullOrWhiteSpace(text)) {&para;<br>					text = "The download process succeeded, but there was a problem reading the file data.";&para;<br>					await App.Msg("Download Error", text, "OK");&para;<br>					return Result&lt;object&gt;.Fail(text);&para;<br>				}&para;<br>&para;<br>				var type = doThis == Then.SaveOffline ? Under.Documents : Under.Temp;&para;<br>				var doc = new LocalFile(type, name);&para;<br>&para;<br>				doc.Out();&para;<br>&para;<br>				var t1 = text.AsStream();&para;<br>				var save = await doc.Save(t1);&para;<br>&para;<br>				if (string.IsNullOrWhiteSpace(save)) {&para;<br>					return Result&lt;object&gt;.Fail(doc.Name, doc);&para;<br>				}&para;<br>&para;<br>				var action = doThis switch {&para;<br>					Then.Share =&gt; doc.Share(),&para;<br>					Then.View =&gt; await Viewer.Open(doc),&para;<br>					_ =&gt; Result.Succeed&para;<br>				};&para;<br>&para;<br>				if (!action.Success) {&para;<br>					return Result&lt;object&gt;.Fail(action.Error, doc);&para;<br>				}&para;<br>&para;<br>				return Result&lt;object&gt;.Succeed(doc);&para;<br>			}&para;<br>		}&para;<br>&para;<br>		[AttributeUsage(AttributeTargets.All, Inherited = false, AllowMultiple = false)]&para;<br>		public class DocumentsMethod : Attribute {&para;<br></span><del style="background:#ffe6e6;">&para;<br>		}&para;<br>		[AttributeUsage(AttributeTargets.All, Inherited = false, AllowMultiple = true)]&para;<br>		public class Summary : Attribute {&para;<br>			public string Comment { get; set; }&para;<br>			public Summary(string comment) {&para;<br>				Comment = comment;&para;<br>			}</del><span>&para;<br>		}&para;<br>&para;<br>		#endregion&para;<br>&para;<br>	}&para;<br>}&para;<br></span>